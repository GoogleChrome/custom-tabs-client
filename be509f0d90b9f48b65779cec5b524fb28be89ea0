{
  "comments": [
    {
      "key": {
        "uuid": "e73b7a90_8b5b39f1",
        "filename": "customtabs/src/android/support/customtabs/browseractions/BrowserServiceFileProvider.java",
        "patchSetId": 10
      },
      "lineNbr": 182,
      "author": {
        "id": 1116043
      },
      "writtenOn": "2018-01-17T23:20:33Z",
      "side": 1,
      "message": "Another potentially nefarious case, but what happens if two callers query at the same time?  Would that dead lock the first adder of the sempahore as it would be overridden?\n\nI wonder if we used something like:\nhttps://developer.android.com/reference/java/util/concurrent/Semaphore.html#getQueueLength()\nor\nhttps://developer.android.com/reference/java/util/concurrent/Semaphore.html#hasQueuedThreads()\n\nTo do a bigger release of permits.  We could conceptually just call release with MAX_INT above and handle that case if we expected that to never happen (and we\u0027d never rewrite the semaphore here).\n\nAnother thing to investigate is whether this would be better:\nhttps://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock.html\n\nDoes that give better control conceptually of this?  Haven\u0027t done any investigation and I think we could likely avoid it by doing the larger calls of release(...) but it would be good to investigate that quickly as another foundational component of the concurrent library in java.",
      "revId": "be509f0d90b9f48b65779cec5b524fb28be89ea0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d0c7d837_f22afa7b",
        "filename": "customtabs/src/android/support/customtabs/browseractions/BrowserServiceFileProvider.java",
        "patchSetId": 10
      },
      "lineNbr": 182,
      "author": {
        "id": 1233200
      },
      "writtenOn": "2018-01-18T01:33:10Z",
      "side": 1,
      "message": "ReentrantReadWriteLock seems has no way to block until write is finished and Semaphore#getQueueLength() does not work because acquire is out the synchronized block.\n\nI use negative permit number to indicate how many threads are waiting and when write finishes, flip the permit number to positive so all waiting threads can access.\n\nAnother options is release enough MAX_INT.",
      "parentUuid": "e73b7a90_8b5b39f1",
      "revId": "be509f0d90b9f48b65779cec5b524fb28be89ea0",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}