{
  "comments": [
    {
      "key": {
        "uuid": "a68956c2_2bffeca9",
        "filename": "customtabs/build.gradle",
        "patchSetId": 1
      },
      "lineNbr": 16,
      "author": {
        "id": 1149979
      },
      "writtenOn": "2019-05-17T12:02:36Z",
      "side": 1,
      "message": "I was originally concerned about this dependency for when we move this code into AndroidX, but it looks like they have a similar dependency, though it\u0027s on version 2.19.0. Could you check if your code all works with that version to make upstreaming easier?",
      "range": {
        "startLine": 16,
        "startChar": 44,
        "endLine": 16,
        "endChar": 61
      },
      "revId": "0f8bfa873d9aadc83586f391f239528476c9eddc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d565add0_1c98e0db",
        "filename": "customtabs/tests/src/android/support/customtabs/TestCustomTabsService.java",
        "patchSetId": 1
      },
      "lineNbr": 133,
      "author": {
        "id": 1149979
      },
      "writtenOn": "2019-05-17T12:02:36Z",
      "side": 1,
      "message": "You\u0027re using the CountDownLatch to wait for receiveFile (which I\u0027m assuming may be called on a different thread to waitForSplashImageFile) to complete successfully. There\u0027s a slight problem though because you\u0027re creating this new CountDownLatch on a certain thread and a subsequent call to receiveFile on another thread may still use the old one.\n\nI\u0027m sure things will work fine in the tests though, so you may want to just add a comment saying that it\u0027s not 100% threadsafe. Otherwise you\u0027ll need to make mFileReceivingLatch volatile (or use an AtomicReference) and lock on some object around accessing/creating.\n\nAlternatively you could change the CountDownLatch to a CyclicBarrier and call reset instead of creating a new one.",
      "range": {
        "startLine": 133,
        "startChar": 12,
        "endLine": 133,
        "endChar": 31
      },
      "revId": "0f8bfa873d9aadc83586f391f239528476c9eddc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c29faf15_0f2f3c4b",
        "filename": "customtabs/tests/src/android/support/customtabs/testutil/CustomTabConnectionRule.java",
        "patchSetId": 1
      },
      "lineNbr": 60,
      "author": {
        "id": 1149979
      },
      "writtenOn": "2019-05-17T12:02:36Z",
      "side": 1,
      "message": "If this method returns false you can return null and not waste 2 seconds.",
      "range": {
        "startLine": 60,
        "startChar": 25,
        "endLine": 60,
        "endChar": 46
      },
      "revId": "0f8bfa873d9aadc83586f391f239528476c9eddc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "581b5156_940a1493",
        "filename": "customtabs/tests/src/android/support/customtabs/trusted/splashscreens/PwaWrapperSplashScreenStrategyTest.java",
        "patchSetId": 1
      },
      "lineNbr": 114,
      "author": {
        "id": 1149979
      },
      "writtenOn": "2019-05-17T12:02:36Z",
      "side": 1,
      "message": "I\u0027m confused by this behaviour - don\u0027t we still want to show the splashscreen in the client even if the browser doesn\u0027t support it?",
      "range": {
        "startLine": 114,
        "startChar": 16,
        "endLine": 114,
        "endChar": 75
      },
      "revId": "0f8bfa873d9aadc83586f391f239528476c9eddc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e92c4dda_4f2c22ea",
        "filename": "customtabs/tests/src/android/support/customtabs/trusted/splashscreens/PwaWrapperSplashScreenStrategyTest.java",
        "patchSetId": 1
      },
      "lineNbr": 160,
      "author": {
        "id": 1149979
      },
      "writtenOn": "2019-05-17T12:02:36Z",
      "side": 1,
      "message": "Don\u0027t we need some sort of synchronisation here to block the test until the provided runnable is executed? From what I can tell, PwaWrapperSplashScreenStrategy#configureTwaBuilder will call into SplashImageTransferTask#execute which launches an AsyncTask.",
      "range": {
        "startLine": 160,
        "startChar": 8,
        "endLine": 160,
        "endChar": 11
      },
      "revId": "0f8bfa873d9aadc83586f391f239528476c9eddc",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}